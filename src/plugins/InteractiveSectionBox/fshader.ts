export const fshader = "precision highp float;\r\n\r\nuniform mat4 transformations[6];\r\n\r\nuniform mat4 inverseProjectionMatrix;\r\nuniform vec2 viewportDimensions;\r\nuniform mat4 uPMatrix;\r\n\r\nvarying vec4 vColor;\r\nvarying mat4 planeTrsf;\r\nvarying vec3 FragPos;\r\n\r\nvec3 CalcEyeFromWindow(void)\r\n{\r\n vec3 ndcPos;\r\n ndcPos.xy = (2.0 * gl_FragCoord.xy) / viewportDimensions - 1.;\r\n ndcPos.z = (2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far) /\r\n (gl_DepthRange.far - gl_DepthRange.near);\r\n vec4 clipPos;\r\n clipPos.w = uPMatrix[3][2] /\r\n (ndcPos.z - (uPMatrix[2][2] / uPMatrix[2][3]));\r\n clipPos.xyz = ndcPos * clipPos.w;\r\n\r\n return (inverseProjectionMatrix * clipPos).xyz;\r\n} \r\n\r\nbool isFrontFacing(mat4 trsf, vec3 point){\r\n vec3 planeNormal = vec3(trsf[0][0], trsf[1][0], trsf[2][0]);\r\n vec3 planePoint = vec3(trsf[0][3], trsf[1][3], trsf[2][3]);\r\n float planeD = -dot(planeNormal, planePoint);\r\n float positionRelative = dot(planeNormal, point) + planeD;\r\n return positionRelative <= 0.;\r\n}\r\n\r\nfloat getFrontFacing(mat4 trsf, vec3 point){\r\n vec3 planeNormal = vec3(trsf[0][0], trsf[0][1], trsf[0][2]);\r\n vec3 planePoint = vec3(trsf[3][0], trsf[3][1], trsf[3][2]);\r\n float planeD = -dot(planeNormal, planePoint);\r\n float positionRelative = dot(planeNormal, point) + planeD;\r\n return positionRelative;\r\n}\r\n\r\nvoid main(void) {\r\n\r\n bool ignoreFragment = false;\r\n vec3 viewPos = CalcEyeFromWindow();\r\n vec3 color = vec3(0.0);\r\n for(int i = 0; i < 6; i++){\r\n mat4 trsf = transformations[i];\r\n if(isFrontFacing(trsf, viewPos)){\r\n ignoreFragment = true;\r\n vec3 planeNormal = vec3(trsf[0][0], trsf[0][1], trsf[0][2]);\r\n color = planeNormal * getFrontFacing(planeTrsf, viewPos);\r\n break;\r\n }\r\n }\r\n\r\n gl_FragColor = vec4(((vec4((FragPos), 1.0)).xyz+vec3(100.))/100., 1.0);\r\n gl_FragColor = vColor;\r\n}"